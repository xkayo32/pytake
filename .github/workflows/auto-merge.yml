name: üîÑ Auto-Merge PRs on Success

on:
  pull_request:
    types: [opened, reopened, synchronize]
  check_suite:
    types: [completed]

permissions:
  pull-requests: write
  contents: write

jobs:
  check-and-auto-merge:
    name: Check CI and Enable Auto-Merge
    runs-on: ubuntu-latest
    if: github.base_ref == 'develop'
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üìä Wait for Checks
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = context.issue.number;

            // Wait a bit for checks to start
            await new Promise(resolve => setTimeout(resolve, 5000));

            let attempts = 0;
            const maxAttempts = 60; // ~5 minutes

            while (attempts < maxAttempts) {
              try {
                const { data: pr } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pr_number,
                });

                // Skip if draft or already merged
                if (pr.draft || pr.merged) {
                  console.log(`‚è≠Ô∏è  PR #${pr_number} - Draft: ${pr.draft}, Merged: ${pr.merged}`);
                  return;
                }

                const { data: checks } = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: pr.head.sha,
                });

                // Get status checks
                const { data: statuses } = await github.rest.repos.getCombinedStatusForRef({
                  owner,
                  repo,
                  ref: pr.head.sha,
                });

                const allChecks = [
                  ...checks.check_runs,
                  ...(statuses.statuses || [])
                ];

                if (allChecks.length === 0) {
                  attempts++;
                  await new Promise(resolve => setTimeout(resolve, 5000));
                  continue;
                }

                const running = allChecks.filter(c => c.status !== 'completed' && c.conclusion !== 'success' && c.conclusion !== 'failure');
                const failed = allChecks.filter(c => c.conclusion === 'failure');
                const passed = allChecks.filter(c => c.status === 'completed' && c.conclusion === 'success');

                console.log(`üìä Checks - Running: ${running.length}, Passed: ${passed.length}, Failed: ${failed.length}`);

                if (running.length === 0 && failed.length === 0 && passed.length > 0) {
                  // All passed!
                  console.log('‚úÖ All checks passed!');
                  
                  try {
                    await github.rest.pulls.enableAutoMerge({
                      owner,
                      repo,
                      pull_number: pr_number,
                      merge_method: 'rebase',
                    });
                    
                    console.log(`‚úÖ Auto-merge ATIVADO para PR #${pr_number}`);
                    
                    // Post comment
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: pr_number,
                      body: '‚úÖ CI/CD passou! Auto-merge ativado automaticamente.'
                    });
                  } catch (error) {
                    console.log(`‚ö†Ô∏è  Erro ao ativar auto-merge: ${error.message}`);
                  }
                  return;
                }

                if (failed.length > 0) {
                  console.log('‚ùå Some checks failed');
                  return;
                }

              } catch (error) {
                console.log(`Error: ${error.message}`);
              }

              attempts++;
              await new Promise(resolve => setTimeout(resolve, 5000));
            }

            console.log('‚è±Ô∏è  Timeout waiting for checks');
