# üìä An√°lise Completa do Motor de Execu√ß√£o de Fluxo do Chatbot

**Data:** 2025-10-15
**Status:** ‚úÖ Funcionando - Fluxo b√°sico completo

---

## ‚úÖ O Que Est√° Implementado

### 1. **Node Types Suportados**

| Node Type | Status | Funcionalidade |
|-----------|--------|----------------|
| `start` | ‚úÖ Completo | Ponto de entrada do fluxo |
| `question` | ‚úÖ Completo | Pergunta ao usu√°rio e aguarda resposta |
| `message` | ‚úÖ Completo | Envia mensagem e avan√ßa automaticamente |
| `end` | ‚úÖ Completo | Mensagem de despedida e finaliza√ß√£o |

### 2. **Recursos Implementados**

‚úÖ **Navega√ß√£o entre nodes**
- Segue edges do `canvas_data` (React Flow)
- Busca nodes dinamicamente no banco
- Suporta qualquer estrutura de fluxo

‚úÖ **Substitui√ß√£o de vari√°veis**
- Formato: `{{variable_name}}`
- Usa `outputVariable` do node (definido no builder)
- Salva em `conversation.context_variables`

‚úÖ **Gerenciamento de estado**
- `active_flow_id`: Flow em execu√ß√£o
- `current_node_id`: Posi√ß√£o atual no fluxo
- `context_variables`: Vari√°veis coletadas
- `is_bot_active`: Controle de ativa√ß√£o

‚úÖ **Tratamento de mensagens**
- WhatsApp Meta Cloud API ‚úÖ
- WhatsApp Evolution API (QR Code) ‚úÖ
- Salva mensagens no banco
- Emite eventos WebSocket

‚úÖ **L√≥gica de execu√ß√£o**
- **Question nodes**: Aguardam resposta do usu√°rio
- **Message/End nodes**: Avan√ßam automaticamente
- **End node**: Finaliza fluxo e desativa bot

---

## ‚ö†Ô∏è Limita√ß√µes Atuais

### 1. **Campos de Nodes N√£o Utilizados**

**Question Node:**
```json
{
  "questionText": "OK ‚úÖ",
  "outputVariable": "OK ‚úÖ",
  "responseType": "text", // ‚ùå N√£o validado (number, email, phone)
  "options": [], // ‚ùå N√£o implementado (op√ß√µes de escolha)
  "validation": {
    "required": true, // ‚ùå N√£o validado
    "maxAttempts": 3, // ‚ùå N√£o implementado
    "errorMessage": "..." // ‚ùå N√£o usado
  }
}
```

**Message Node:**
```json
{
  "messageText": "OK ‚úÖ",
  "messageType": "text", // ‚ùå S√≥ suporta text (n√£o image, video, document)
  "mediaUrl": null, // ‚ùå N√£o implementado
  "delay": 0, // ‚ùå N√£o implementado
  "autoAdvance": true // OK ‚úÖ (sempre avan√ßa)
}
```

**End Node:**
```json
{
  "farewellMessage": "OK ‚úÖ",
  "sendFarewell": true, // OK ‚úÖ
  "closeConversation": false, // ‚ùå N√£o implementado
  "saveConversation": true, // ‚ùå N√£o implementado
  "addTag": null, // ‚ùå N√£o implementado
  "sendSummary": false, // ‚ùå N√£o implementado
  "endType": "close" // ‚ùå N√£o usado
}
```

### 2. **Node Types Avan√ßados N√£o Implementados**

| Node Type | Prioridade | Descri√ß√£o |
|-----------|-----------|-----------|
| `condition` | üî• Alta | Ramifica√ß√£o baseada em condi√ß√µes (if/else) |
| `action` | üî• Alta | A√ß√µes (salvar contato, webhook, API, etc) |
| `handoff` | üî• Alta | Transferir para agente humano |
| `jump` | üü° M√©dia | Pular para outro node/flow |
| `delay` | üü° M√©dia | Aguardar X segundos antes de avan√ßar |
| `api_call` | üü¢ Baixa | Fazer chamada HTTP externa |
| `ai_prompt` | üü¢ Baixa | Interagir com LLM (GPT, Claude) |
| `script` | üü¢ Baixa | Executar JavaScript/Python |
| `database_query` | üü¢ Baixa | Consultar banco de dados |
| `whatsapp_template` | üü¢ Baixa | Enviar template oficial WhatsApp |
| `interactive_buttons` | üü¢ Baixa | Bot√µes interativos |
| `interactive_list` | üü¢ Baixa | Lista de sele√ß√£o |

### 3. **Valida√ß√µes Ausentes**

‚ùå **Valida√ß√£o de resposta do usu√°rio**
- N√£o valida `responseType` (text, number, email, phone)
- N√£o verifica se resposta est√° vazia
- N√£o implementa `maxAttempts` (tentar novamente)

‚ùå **Tratamento de erros de envio**
- Se WhatsApp API falhar, fluxo trava
- N√£o h√° retry autom√°tico
- N√£o notifica usu√°rio sobre erro

‚ùå **Loops infinitos**
- N√£o detecta edges circulares
- Pode entrar em loop se mal configurado

‚ùå **Timeout**
- N√£o tem limite de tempo para respostas
- Conversa pode ficar "presa" indefinidamente

---

## üöÄ Melhorias Recomendadas

### **Prioridade ALTA (Implementar Primeiro)**

#### 1. **Condition Node** üî•
Ramifica√ß√£o baseada em vari√°veis coletadas.

**Exemplo:**
```
Question: "Qual sua idade?"
  ‚Üì
Condition: idade >= 18
  ‚îú‚îÄ true ‚Üí Message: "Voc√™ pode prosseguir"
  ‚îî‚îÄ false ‚Üí Message: "Voc√™ precisa ser maior de 18"
```

**Implementa√ß√£o:**
```python
if node.node_type == "condition":
    conditions = node_data.get("conditions", [])
    for condition in conditions:
        var_name = condition["variable"]
        operator = condition["operator"]  # ==, !=, >, <, >=, <=, contains
        value = condition["value"]

        # Avaliar condi√ß√£o
        var_value = context_vars.get(var_name)
        if eval_condition(var_value, operator, value):
            # Seguir edge com label "true"
            next_node_id = find_edge(node_id, "true")
        else:
            # Seguir edge com label "false"
            next_node_id = find_edge(node_id, "false")
```

#### 2. **Handoff Node** üî•
Transferir para agente humano.

**Implementa√ß√£o:**
```python
if node.node_type == "handoff":
    # Desativar bot
    await conv_repo.update(conversation.id, {
        "is_bot_active": False,
        "status": "queued",  # Adicionar √† fila
        "assigned_queue_id": node_data.get("queueId")
    })

    # Opcional: enviar mensagem de transfer√™ncia
    await send_message("Transferindo para um agente humano...")

    # Finalizar fluxo
    await self._finalize_flow(conversation)
```

#### 3. **Valida√ß√£o de Resposta** üî•

**Implementa√ß√£o:**
```python
async def _validate_user_response(self, user_text, node_data):
    response_type = node_data.get("responseType", "text")

    if response_type == "number":
        if not user_text.isdigit():
            return False, "Por favor, digite um n√∫mero v√°lido"

    elif response_type == "email":
        if "@" not in user_text:
            return False, "Por favor, digite um e-mail v√°lido"

    elif response_type == "phone":
        phone = re.sub(r'\D', '', user_text)
        if len(phone) < 10:
            return False, "Por favor, digite um telefone v√°lido"

    return True, None

# Usar na _process_user_response_and_advance:
valid, error_msg = await self._validate_user_response(user_text, node_data)
if not valid:
    # Incrementar tentativa
    attempts = context_vars.get(f"{node.node_id}_attempts", 0) + 1
    max_attempts = node_data.get("validation", {}).get("maxAttempts", 3)

    if attempts >= max_attempts:
        # Enviar erro e avan√ßar
        await send_message("N√∫mero m√°ximo de tentativas excedido.")
        await self._advance_to_next_node(...)
    else:
        # Enviar erro e aguardar nova resposta
        error_message = node_data.get("validation", {}).get("errorMessage", error_msg)
        await send_message(error_message)
        # Salvar n√∫mero de tentativas
        context_vars[f"{node.node_id}_attempts"] = attempts
        return  # N√£o avan√ßar
```

### **Prioridade M√âDIA (Depois das altas)**

#### 4. **Delay Node** üü°
Aguardar X segundos antes de avan√ßar.

**Implementa√ß√£o com Celery:**
```python
if node.node_type == "delay":
    delay_seconds = node_data.get("delay", 0)

    # Agendar task Celery para continuar depois
    from app.tasks.chatbot import continue_flow_after_delay

    continue_flow_after_delay.apply_async(
        args=[conversation.id, node.id, flow.id],
        countdown=delay_seconds
    )

    return  # N√£o avan√ßar agora
```

#### 5. **Message Types (Image, Video, Document)** üü°

**Implementa√ß√£o:**
```python
message_type = node_data.get("messageType", "text")
media_url = node_data.get("mediaUrl")

if message_type == "image" and media_url:
    await meta_api.send_image_message(
        to=contact_whatsapp_id,
        image_url=media_url,
        caption=final_text
    )
elif message_type == "video" and media_url:
    await meta_api.send_video_message(...)
elif message_type == "document" and media_url:
    await meta_api.send_document_message(...)
```

#### 6. **Jump Node** üü°
Pular para outro node ou flow.

**Implementa√ß√£o:**
```python
if node.node_type == "jump":
    jump_type = node_data.get("jumpType")  # "node" ou "flow"

    if jump_type == "node":
        target_node_id = node_data.get("targetNodeId")
        # Buscar e executar target node

    elif jump_type == "flow":
        target_flow_id = node_data.get("targetFlowId")
        # Mudar active_flow_id e executar novo flow
```

### **Prioridade BAIXA (Futuras)**

- `api_call`: Chamadas HTTP externas
- `ai_prompt`: Integra√ß√£o com LLMs
- `script`: Execu√ß√£o de c√≥digo customizado
- `database_query`: Consultas SQL/NoSQL
- `whatsapp_template`: Templates oficiais WhatsApp
- `interactive_buttons`: Bot√µes interativos
- `interactive_list`: Listas de sele√ß√£o

---

## üõ°Ô∏è Prote√ß√µes Necess√°rias

### 1. **Detec√ß√£o de Loops**
```python
# Rastrear nodes visitados
visited_nodes = context_vars.get("_visited_nodes", [])
if node.node_id in visited_nodes[-5:]:  # Loop detectado
    logger.error(f"Loop infinito detectado em {node.node_id}")
    await self._finalize_flow(conversation)
    return

visited_nodes.append(node.node_id)
context_vars["_visited_nodes"] = visited_nodes[-10:]  # Manter √∫ltimos 10
```

### 2. **Timeout de Resposta**
```python
# Na cria√ß√£o da conversa ou in√≠cio do fluxo
context_vars["_flow_started_at"] = datetime.utcnow().isoformat()

# Em cada execu√ß√£o
flow_started_at = datetime.fromisoformat(context_vars.get("_flow_started_at"))
elapsed = (datetime.utcnow() - flow_started_at).total_seconds()

if elapsed > 3600:  # 1 hora
    logger.warning(f"Fluxo timeout ap√≥s {elapsed}s")
    await self._finalize_flow(conversation)
    return
```

### 3. **Retry de Envio**
```python
max_retries = 3
for attempt in range(max_retries):
    try:
        response = await meta_api.send_text_message(...)
        break  # Sucesso
    except Exception as e:
        if attempt == max_retries - 1:
            logger.error(f"Falha ap√≥s {max_retries} tentativas")
            # Salvar mensagem com status "failed"
            return
        await asyncio.sleep(2 ** attempt)  # Exponential backoff
```

---

## üìà M√©tricas de Sucesso

### **M√©tricas Atuais (Funcionando)**
‚úÖ Taxa de conclus√£o de fluxo (end node atingido)
‚úÖ Tempo m√©dio de execu√ß√£o
‚úÖ N√∫mero de mensagens enviadas
‚úÖ N√∫mero de vari√°veis coletadas

### **M√©tricas Futuras**
- Taxa de drop-off por node (onde usu√°rios param)
- Taxa de erro de valida√ß√£o
- Taxa de handoff para humano
- Tempo m√©dio de resposta do usu√°rio
- Taxa de reengajamento ap√≥s timeout

---

## üéØ Resumo

### **O Que Funciona MUITO BEM:**
‚úÖ Navega√ß√£o entre nodes
‚úÖ Substitui√ß√£o de vari√°veis
‚úÖ Gerenciamento de estado
‚úÖ Envio via WhatsApp (Meta API + Evolution API)
‚úÖ Question/Message/End nodes b√°sicos

### **Prioridades de Implementa√ß√£o:**
1. üî• **Condition Node** - Ramifica√ß√£o l√≥gica
2. üî• **Handoff Node** - Transferir para humano
3. üî• **Valida√ß√£o de resposta** - Tipos e retry
4. üü° **Delay Node** - Aguardar X segundos
5. üü° **Message types** - Imagem, v√≠deo, documento

### **Prote√ß√µes Cr√≠ticas:**
- Detec√ß√£o de loops infinitos
- Timeout de respostas
- Retry autom√°tico de envio
- Logs detalhados de erros

---

## üìù Conclus√£o

O motor de execu√ß√£o atual est√° **funcional e robusto** para fluxos b√°sicos:
- **Start ‚Üí Question ‚Üí Message ‚Üí End** ‚úÖ

Para produ√ß√£o, recomendo implementar:
1. Condition Node (ramifica√ß√£o)
2. Handoff Node (transferir para humano)
3. Valida√ß√µes de resposta

O resto pode ser adicionado conforme demanda real dos usu√°rios.

**Status Final:** üü¢ Pronto para fluxos b√°sicos, com roadmap claro para expans√£o.
